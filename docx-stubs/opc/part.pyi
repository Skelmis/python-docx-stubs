"""
This type stub file was generated by pyright.
"""

from .shared import lazyproperty

"""
Open Packaging Convention (OPC) objects related to package parts.
"""
class Part:
    """
    Base class for package parts. Provides common properties and methods, but
    intended to be subclassed in client code to implement specific part
    behaviors.
    """
    def __init__(self, partname, content_type, blob=..., package=...) -> None:
        ...
    
    def after_unmarshal(self): # -> None:
        """
        Entry point for post-unmarshaling processing, for example to parse
        the part XML. May be overridden by subclasses without forwarding call
        to super.
        """
        ...
    
    def before_marshal(self): # -> None:
        """
        Entry point for pre-serialization processing, for example to finalize
        part naming if necessary. May be overridden by subclasses without
        forwarding call to super.
        """
        ...
    
    @property
    def blob(self): # -> None:
        """
        Contents of this package part as a sequence of bytes. May be text or
        binary. Intended to be overridden by subclasses. Default behavior is
        to return load blob.
        """
        ...
    
    @property
    def content_type(self): # -> Unknown:
        """
        Content type of this part.
        """
        ...
    
    def drop_rel(self, rId): # -> None:
        """
        Remove the relationship identified by *rId* if its reference count
        is less than 2. Relationships with a reference count of 0 are
        implicit relationships.
        """
        ...
    
    @classmethod
    def load(cls, partname, content_type, blob, package): # -> Self@Part:
        ...
    
    def load_rel(self, reltype, target, rId, is_external=...): # -> Any:
        """
        Return newly added |_Relationship| instance of *reltype* between this
        part and *target* with key *rId*. Target mode is set to
        ``RTM.EXTERNAL`` if *is_external* is |True|. Intended for use during
        load from a serialized package, where the rId is well-known. Other
        methods exist for adding a new relationship to a part when
        manipulating a part.
        """
        ...
    
    @property
    def package(self): # -> None:
        """
        |OpcPackage| instance this part belongs to.
        """
        ...
    
    @property
    def partname(self): # -> Unknown | PackURI:
        """
        |PackURI| instance holding partname of this part, e.g.
        '/ppt/slides/slide1.xml'
        """
        ...
    
    @partname.setter
    def partname(self, partname): # -> None:
        ...
    
    def part_related_by(self, reltype): # -> Any:
        """
        Return part to which this part has a relationship of *reltype*.
        Raises |KeyError| if no such relationship is found and |ValueError|
        if more than one such relationship is found. Provides ability to
        resolve implicitly related part, such as Slide -> SlideLayout.
        """
        ...
    
    def relate_to(self, target, reltype, is_external=...): # -> Any:
        """
        Return rId key of relationship of *reltype* to *target*, from an
        existing relationship if there is one, otherwise a newly created one.
        """
        ...
    
    @property
    def related_parts(self): # -> Any:
        """
        Dictionary mapping related parts by rId, so child objects can resolve
        explicit relationships present in the part XML, e.g. sldIdLst to a
        specific |Slide| instance.
        """
        ...
    
    @lazyproperty
    def rels(self): # -> Relationships:
        """
        |Relationships| instance holding the relationships for this part.
        """
        ...
    
    def target_ref(self, rId): # -> Any:
        """
        Return URL contained in target ref of relationship identified by
        *rId*.
        """
        ...
    


class PartFactory:
    """
    Provides a way for client code to specify a subclass of |Part| to be
    constructed by |Unmarshaller| based on its content type and/or a custom
    callable. Setting ``PartFactory.part_class_selector`` to a callable
    object will cause that object to be called with the parameters
    ``content_type, reltype``, once for each part in the package. If the
    callable returns an object, it is used as the class for that part. If it
    returns |None|, part class selection falls back to the content type map
    defined in ``PartFactory.part_type_for``. If no class is returned from
    either of these, the class contained in ``PartFactory.default_part_type``
    is used to construct the part, which is by default ``opc.package.Part``.
    """
    part_class_selector = ...
    part_type_for = ...
    default_part_type = Part
    def __new__(cls, partname, content_type, reltype, blob, package): # -> default_part_type | Any:
        ...
    


class XmlPart(Part):
    """
    Base class for package parts containing an XML payload, which is most of
    them. Provides additional methods to the |Part| base class that take care
    of parsing and reserializing the XML payload and managing relationships
    to other parts.
    """
    def __init__(self, partname, content_type, element, package) -> None:
        ...
    
    @property
    def blob(self):
        ...
    
    @property
    def element(self): # -> Unknown:
        """
        The root XML element of this XML part.
        """
        ...
    
    @classmethod
    def load(cls, partname, content_type, blob, package): # -> Self@XmlPart:
        ...
    
    @property
    def part(self): # -> Self@XmlPart:
        """
        Part of the parent protocol, "children" of the document will not know
        the part that contains them so must ask their parent object. That
        chain of delegation ends here for child objects.
        """
        ...
    


